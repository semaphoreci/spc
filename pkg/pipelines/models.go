// Code generated by schema-generate. DO NOT EDIT.

package pipelines

import (
    "bytes"
    "errors"
    "encoding/json"
    "fmt"
)

// Agent 
type Agent struct {
  Containers []*ContainersItems `json:"containers,omitempty"`
  ImagePullSecrets []*ImagePullSecretsItems `json:"image_pull_secrets,omitempty"`
  Machine *Machine `json:"machine"`
}

// AutoCancel 
type AutoCancel struct {
  Queued *WhenCondition `json:"queued,omitempty"`
  Running *WhenCondition `json:"running,omitempty"`
}

// AutoPromoteCondition 
type AutoPromoteCondition struct {
  Branch []string `json:"branch,omitempty"`
  LabelPatterns []string `json:"label_patterns,omitempty"`
  Labels []string `json:"labels,omitempty"`
  Result string `json:"result"`
  ResultReason string `json:"result_reason,omitempty"`
}

// Block 
type Block struct {
  Dependencies []string `json:"dependencies,omitempty"`
  ExecutionTimeLimit *ExecutionTimeLimit `json:"execution_time_limit,omitempty"`
  Filters []*FiltersItems `json:"filters,omitempty"`
  Name string `json:"name,omitempty"`
  Run *WhenCondition `json:"run,omitempty"`
  Skip *WhenCondition `json:"skip,omitempty"`
  Task *Task `json:"task,omitempty"`
  TaskFile string `json:"task_file,omitempty"`
}

// Booster 
type Booster struct {
  JobCount int `json:"job_count,omitempty"`
  Name string `json:"name,omitempty"`
  Type interface{} `json:"type,omitempty"`
}

// BoostersItems 
type BoostersItems struct {
}

// BuildMatrix 
type BuildMatrix struct {
  EnvVar string `json:"env_var"`
  Values []string `json:"values"`
}

// CmdType 
type CmdType struct {
  Commands []string `json:"commands,omitempty"`
  CommandsFile string `json:"commands_file,omitempty"`
}

// ConditionalEpilogue 
type ConditionalEpilogue struct {
  Always *CmdType `json:"always,omitempty"`
  OnFail *CmdType `json:"on_fail,omitempty"`
  OnPass *CmdType `json:"on_pass,omitempty"`
}

// Container 
type Container struct {
  Command string `json:"command,omitempty"`
  Entrypoint string `json:"entrypoint,omitempty"`
  EnvVars []*EnvVarsItems `json:"env_vars,omitempty"`
  Image string `json:"image"`
  Name string `json:"name"`
  Secrets []*SecretsItems `json:"secrets,omitempty"`
  User string `json:"user,omitempty"`
}

// ContainersItems 
type ContainersItems struct {
}

// EnvVar 
type EnvVar struct {
  Name string `json:"name"`
  Value string `json:"value"`
}

// EnvVarsItems 
type EnvVarsItems struct {
}

// Epilogue 
type Epilogue struct {
}

// ExecutionTimeLimit 
type ExecutionTimeLimit struct {
  Hours int `json:"hours,omitempty"`
  Minutes int `json:"minutes,omitempty"`
}

// FailFast 
type FailFast struct {
  Cancel *WhenCondition `json:"cancel,omitempty"`
  Stop *WhenCondition `json:"stop,omitempty"`
}

// FiltersItems 
type FiltersItems struct {
  Action string `json:"action,omitempty"`
  Label string `json:"label,omitempty"`
  LabelPattern string `json:"label_pattern,omitempty"`
}

// GlobalJobConfig 
type GlobalJobConfig struct {
  EnvVars []*EnvVarsItems `json:"env_vars,omitempty"`
  Epilogue *Epilogue `json:"epilogue,omitempty"`
  Priority []*PriorityItems `json:"priority,omitempty"`
  Prologue *CmdType `json:"prologue,omitempty"`
  Secrets []*SecretsItems `json:"secrets,omitempty"`
}

// ImagePullSecret 
type ImagePullSecret struct {
  Name string `json:"name"`
}

// ImagePullSecretsItems 
type ImagePullSecretsItems struct {
}

// Job 
type Job struct {
  Commands []string `json:"commands,omitempty"`
  CommandsFile string `json:"commands_file,omitempty"`
  EnvVars []*EnvVarsItems `json:"env_vars,omitempty"`
  ExecutionTimeLimit *ExecutionTimeLimit `json:"execution_time_limit,omitempty"`
  Matrix []*MatrixItems `json:"matrix,omitempty"`
  Name string `json:"name,omitempty"`
  Parallelism int `json:"parallelism,omitempty"`
  Priority []*PriorityItems `json:"priority,omitempty"`
}

// JobsItems 
type JobsItems struct {
}

// Machine 
type Machine struct {
  OsImage string `json:"os_image,omitempty"`
  Type string `json:"type"`
}

// MatrixItems 
type MatrixItems struct {
}

// ParameterEnvVar 
type ParameterEnvVar struct {
  DefaultValue string `json:"default_value,omitempty"`
  Description string `json:"description,omitempty"`
  Name string `json:"name"`
  Options []string `json:"options,omitempty"`
  Required bool `json:"required,omitempty"`
}

// Parameters 
type Parameters struct {
  EnvVars []*ParameterEnvVar `json:"env_vars"`
}

// Pipeline 
type Pipeline struct {
  Agent *Agent `json:"agent"`
  AutoCancel *AutoCancel `json:"auto_cancel,omitempty"`
  Blocks []*Block `json:"blocks"`
  ExecutionTimeLimit *ExecutionTimeLimit `json:"execution_time_limit,omitempty"`
  FailFast *FailFast `json:"fail_fast,omitempty"`
  GlobalJobConfig *GlobalJobConfig `json:"global_job_config,omitempty"`
  Name string `json:"name,omitempty"`
  Promotions []*PromotionsItems `json:"promotions,omitempty"`
  Queue interface{} `json:"queue,omitempty"`
  Version string `json:"version"`
}

// PriorityItems 
type PriorityItems struct {
  Value int `json:"value"`
  When interface{} `json:"when"`
}

// PromotionsItems 
type PromotionsItems struct {
  AutoPromote *WhenCondition `json:"auto_promote,omitempty"`
  AutoPromoteOn []*AutoPromoteCondition `json:"auto_promote_on,omitempty"`
  Name string `json:"name"`
  Parameters *Parameters `json:"parameters,omitempty"`
  PipelineFile string `json:"pipeline_file"`
}

// QueueMap 
type QueueMap struct {
  Name string `json:"name,omitempty"`
  Processing string `json:"processing,omitempty"`
  Scope string `json:"scope,omitempty"`
  When interface{} `json:"when,omitempty"`
}

// Secret 
type Secret struct {
  ConfigFilePaths []string `json:"config_file_paths,omitempty"`
  EnvVarNames []string `json:"env_var_names,omitempty"`
  Name string `json:"name"`
}

// SecretsItems 
type SecretsItems struct {
}

// Task 
type Task struct {
  Agent *Agent `json:"agent,omitempty"`
  Boosters []*BoostersItems `json:"boosters,omitempty"`
  EnvVars []*EnvVarsItems `json:"env_vars,omitempty"`
  Epilogue *Epilogue `json:"epilogue,omitempty"`
  FailFast *FailFast `json:"fail_fast,omitempty"`
  Jobs []*JobsItems `json:"jobs,omitempty"`
  Prologue *CmdType `json:"prologue,omitempty"`
  Secrets []*SecretsItems `json:"secrets,omitempty"`
}

// WhenCondition 
type WhenCondition struct {
  When interface{} `json:"when"`
}

func (strct *Agent) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "containers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"containers\": ")
	if tmp, err := json.Marshal(strct.Containers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "image_pull_secrets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"image_pull_secrets\": ")
	if tmp, err := json.Marshal(strct.ImagePullSecrets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Machine" field is required
    if strct.Machine == nil {
        return nil, errors.New("machine is a required field")
    }
    // Marshal the "machine" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"machine\": ")
	if tmp, err := json.Marshal(strct.Machine); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Agent) UnmarshalJSON(b []byte) error {
    machineReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "containers":
            if err := json.Unmarshal([]byte(v), &strct.Containers); err != nil {
                return err
             }
        case "image_pull_secrets":
            if err := json.Unmarshal([]byte(v), &strct.ImagePullSecrets); err != nil {
                return err
             }
        case "machine":
            if err := json.Unmarshal([]byte(v), &strct.Machine); err != nil {
                return err
             }
            machineReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if machine (a required property) was received
    if !machineReceived {
        return errors.New("\"machine\" is required but was not present")
    }
    return nil
}

func (strct *AutoCancel) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "queued" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"queued\": ")
	if tmp, err := json.Marshal(strct.Queued); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "running" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"running\": ")
	if tmp, err := json.Marshal(strct.Running); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AutoCancel) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "queued":
            if err := json.Unmarshal([]byte(v), &strct.Queued); err != nil {
                return err
             }
        case "running":
            if err := json.Unmarshal([]byte(v), &strct.Running); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *AutoPromoteCondition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "branch" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"branch\": ")
	if tmp, err := json.Marshal(strct.Branch); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "label_patterns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"label_patterns\": ")
	if tmp, err := json.Marshal(strct.LabelPatterns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "labels" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"labels\": ")
	if tmp, err := json.Marshal(strct.Labels); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Result" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "result" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"result\": ")
	if tmp, err := json.Marshal(strct.Result); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "result_reason" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"result_reason\": ")
	if tmp, err := json.Marshal(strct.ResultReason); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AutoPromoteCondition) UnmarshalJSON(b []byte) error {
    resultReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "branch":
            if err := json.Unmarshal([]byte(v), &strct.Branch); err != nil {
                return err
             }
        case "label_patterns":
            if err := json.Unmarshal([]byte(v), &strct.LabelPatterns); err != nil {
                return err
             }
        case "labels":
            if err := json.Unmarshal([]byte(v), &strct.Labels); err != nil {
                return err
             }
        case "result":
            if err := json.Unmarshal([]byte(v), &strct.Result); err != nil {
                return err
             }
            resultReceived = true
        case "result_reason":
            if err := json.Unmarshal([]byte(v), &strct.ResultReason); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if result (a required property) was received
    if !resultReceived {
        return errors.New("\"result\" is required but was not present")
    }
    return nil
}

func (strct *Block) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "dependencies" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"dependencies\": ")
	if tmp, err := json.Marshal(strct.Dependencies); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "execution_time_limit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"execution_time_limit\": ")
	if tmp, err := json.Marshal(strct.ExecutionTimeLimit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "filters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"filters\": ")
	if tmp, err := json.Marshal(strct.Filters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "run" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"run\": ")
	if tmp, err := json.Marshal(strct.Run); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "skip" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"skip\": ")
	if tmp, err := json.Marshal(strct.Skip); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "task" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"task\": ")
	if tmp, err := json.Marshal(strct.Task); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "task_file" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"task_file\": ")
	if tmp, err := json.Marshal(strct.TaskFile); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Block) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "dependencies":
            if err := json.Unmarshal([]byte(v), &strct.Dependencies); err != nil {
                return err
             }
        case "execution_time_limit":
            if err := json.Unmarshal([]byte(v), &strct.ExecutionTimeLimit); err != nil {
                return err
             }
        case "filters":
            if err := json.Unmarshal([]byte(v), &strct.Filters); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "run":
            if err := json.Unmarshal([]byte(v), &strct.Run); err != nil {
                return err
             }
        case "skip":
            if err := json.Unmarshal([]byte(v), &strct.Skip); err != nil {
                return err
             }
        case "task":
            if err := json.Unmarshal([]byte(v), &strct.Task); err != nil {
                return err
             }
        case "task_file":
            if err := json.Unmarshal([]byte(v), &strct.TaskFile); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Booster) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "job_count" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"job_count\": ")
	if tmp, err := json.Marshal(strct.JobCount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Booster) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "job_count":
            if err := json.Unmarshal([]byte(v), &strct.JobCount); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *BuildMatrix) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EnvVar" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "env_var" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"env_var\": ")
	if tmp, err := json.Marshal(strct.EnvVar); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Values" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "values" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"values\": ")
	if tmp, err := json.Marshal(strct.Values); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BuildMatrix) UnmarshalJSON(b []byte) error {
    env_varReceived := false
    valuesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "env_var":
            if err := json.Unmarshal([]byte(v), &strct.EnvVar); err != nil {
                return err
             }
            env_varReceived = true
        case "values":
            if err := json.Unmarshal([]byte(v), &strct.Values); err != nil {
                return err
             }
            valuesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if env_var (a required property) was received
    if !env_varReceived {
        return errors.New("\"env_var\" is required but was not present")
    }
    // check if values (a required property) was received
    if !valuesReceived {
        return errors.New("\"values\" is required but was not present")
    }
    return nil
}

func (strct *CmdType) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "commands" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"commands\": ")
	if tmp, err := json.Marshal(strct.Commands); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "commands_file" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"commands_file\": ")
	if tmp, err := json.Marshal(strct.CommandsFile); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CmdType) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "commands":
            if err := json.Unmarshal([]byte(v), &strct.Commands); err != nil {
                return err
             }
        case "commands_file":
            if err := json.Unmarshal([]byte(v), &strct.CommandsFile); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ConditionalEpilogue) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "always" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"always\": ")
	if tmp, err := json.Marshal(strct.Always); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "on_fail" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"on_fail\": ")
	if tmp, err := json.Marshal(strct.OnFail); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "on_pass" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"on_pass\": ")
	if tmp, err := json.Marshal(strct.OnPass); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ConditionalEpilogue) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "always":
            if err := json.Unmarshal([]byte(v), &strct.Always); err != nil {
                return err
             }
        case "on_fail":
            if err := json.Unmarshal([]byte(v), &strct.OnFail); err != nil {
                return err
             }
        case "on_pass":
            if err := json.Unmarshal([]byte(v), &strct.OnPass); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Container) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "command" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"command\": ")
	if tmp, err := json.Marshal(strct.Command); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "entrypoint" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"entrypoint\": ")
	if tmp, err := json.Marshal(strct.Entrypoint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "env_vars" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"env_vars\": ")
	if tmp, err := json.Marshal(strct.EnvVars); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Image" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "image" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"image\": ")
	if tmp, err := json.Marshal(strct.Image); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "secrets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"secrets\": ")
	if tmp, err := json.Marshal(strct.Secrets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "user" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"user\": ")
	if tmp, err := json.Marshal(strct.User); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Container) UnmarshalJSON(b []byte) error {
    imageReceived := false
    nameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "command":
            if err := json.Unmarshal([]byte(v), &strct.Command); err != nil {
                return err
             }
        case "entrypoint":
            if err := json.Unmarshal([]byte(v), &strct.Entrypoint); err != nil {
                return err
             }
        case "env_vars":
            if err := json.Unmarshal([]byte(v), &strct.EnvVars); err != nil {
                return err
             }
        case "image":
            if err := json.Unmarshal([]byte(v), &strct.Image); err != nil {
                return err
             }
            imageReceived = true
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        case "secrets":
            if err := json.Unmarshal([]byte(v), &strct.Secrets); err != nil {
                return err
             }
        case "user":
            if err := json.Unmarshal([]byte(v), &strct.User); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if image (a required property) was received
    if !imageReceived {
        return errors.New("\"image\" is required but was not present")
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    return nil
}

func (strct *EnvVar) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EnvVar) UnmarshalJSON(b []byte) error {
    nameReceived := false
    valueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        case "value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            valueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    // check if value (a required property) was received
    if !valueReceived {
        return errors.New("\"value\" is required but was not present")
    }
    return nil
}

func (strct *ExecutionTimeLimit) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "hours" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"hours\": ")
	if tmp, err := json.Marshal(strct.Hours); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minutes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minutes\": ")
	if tmp, err := json.Marshal(strct.Minutes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ExecutionTimeLimit) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "hours":
            if err := json.Unmarshal([]byte(v), &strct.Hours); err != nil {
                return err
             }
        case "minutes":
            if err := json.Unmarshal([]byte(v), &strct.Minutes); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FailFast) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "cancel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"cancel\": ")
	if tmp, err := json.Marshal(strct.Cancel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "stop" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"stop\": ")
	if tmp, err := json.Marshal(strct.Stop); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FailFast) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "cancel":
            if err := json.Unmarshal([]byte(v), &strct.Cancel); err != nil {
                return err
             }
        case "stop":
            if err := json.Unmarshal([]byte(v), &strct.Stop); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *FiltersItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "action" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"action\": ")
	if tmp, err := json.Marshal(strct.Action); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "label" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"label\": ")
	if tmp, err := json.Marshal(strct.Label); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "label_pattern" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"label_pattern\": ")
	if tmp, err := json.Marshal(strct.LabelPattern); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FiltersItems) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "action":
            if err := json.Unmarshal([]byte(v), &strct.Action); err != nil {
                return err
             }
        case "label":
            if err := json.Unmarshal([]byte(v), &strct.Label); err != nil {
                return err
             }
        case "label_pattern":
            if err := json.Unmarshal([]byte(v), &strct.LabelPattern); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *GlobalJobConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "env_vars" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"env_vars\": ")
	if tmp, err := json.Marshal(strct.EnvVars); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "epilogue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"epilogue\": ")
	if tmp, err := json.Marshal(strct.Epilogue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "priority" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"priority\": ")
	if tmp, err := json.Marshal(strct.Priority); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "prologue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"prologue\": ")
	if tmp, err := json.Marshal(strct.Prologue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "secrets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"secrets\": ")
	if tmp, err := json.Marshal(strct.Secrets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GlobalJobConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "env_vars":
            if err := json.Unmarshal([]byte(v), &strct.EnvVars); err != nil {
                return err
             }
        case "epilogue":
            if err := json.Unmarshal([]byte(v), &strct.Epilogue); err != nil {
                return err
             }
        case "priority":
            if err := json.Unmarshal([]byte(v), &strct.Priority); err != nil {
                return err
             }
        case "prologue":
            if err := json.Unmarshal([]byte(v), &strct.Prologue); err != nil {
                return err
             }
        case "secrets":
            if err := json.Unmarshal([]byte(v), &strct.Secrets); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ImagePullSecret) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ImagePullSecret) UnmarshalJSON(b []byte) error {
    nameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    return nil
}

func (strct *Job) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "commands" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"commands\": ")
	if tmp, err := json.Marshal(strct.Commands); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "commands_file" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"commands_file\": ")
	if tmp, err := json.Marshal(strct.CommandsFile); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "env_vars" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"env_vars\": ")
	if tmp, err := json.Marshal(strct.EnvVars); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "execution_time_limit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"execution_time_limit\": ")
	if tmp, err := json.Marshal(strct.ExecutionTimeLimit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "matrix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"matrix\": ")
	if tmp, err := json.Marshal(strct.Matrix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "parallelism" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"parallelism\": ")
	if tmp, err := json.Marshal(strct.Parallelism); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "priority" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"priority\": ")
	if tmp, err := json.Marshal(strct.Priority); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Job) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "commands":
            if err := json.Unmarshal([]byte(v), &strct.Commands); err != nil {
                return err
             }
        case "commands_file":
            if err := json.Unmarshal([]byte(v), &strct.CommandsFile); err != nil {
                return err
             }
        case "env_vars":
            if err := json.Unmarshal([]byte(v), &strct.EnvVars); err != nil {
                return err
             }
        case "execution_time_limit":
            if err := json.Unmarshal([]byte(v), &strct.ExecutionTimeLimit); err != nil {
                return err
             }
        case "matrix":
            if err := json.Unmarshal([]byte(v), &strct.Matrix); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "parallelism":
            if err := json.Unmarshal([]byte(v), &strct.Parallelism); err != nil {
                return err
             }
        case "priority":
            if err := json.Unmarshal([]byte(v), &strct.Priority); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Machine) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "os_image" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"os_image\": ")
	if tmp, err := json.Marshal(strct.OsImage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Machine) UnmarshalJSON(b []byte) error {
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "os_image":
            if err := json.Unmarshal([]byte(v), &strct.OsImage); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *ParameterEnvVar) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "default_value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"default_value\": ")
	if tmp, err := json.Marshal(strct.DefaultValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "options" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"options\": ")
	if tmp, err := json.Marshal(strct.Options); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "required" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"required\": ")
	if tmp, err := json.Marshal(strct.Required); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ParameterEnvVar) UnmarshalJSON(b []byte) error {
    nameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "default_value":
            if err := json.Unmarshal([]byte(v), &strct.DefaultValue); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        case "options":
            if err := json.Unmarshal([]byte(v), &strct.Options); err != nil {
                return err
             }
        case "required":
            if err := json.Unmarshal([]byte(v), &strct.Required); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    return nil
}

func (strct *Parameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EnvVars" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "env_vars" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"env_vars\": ")
	if tmp, err := json.Marshal(strct.EnvVars); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Parameters) UnmarshalJSON(b []byte) error {
    env_varsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "env_vars":
            if err := json.Unmarshal([]byte(v), &strct.EnvVars); err != nil {
                return err
             }
            env_varsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if env_vars (a required property) was received
    if !env_varsReceived {
        return errors.New("\"env_vars\" is required but was not present")
    }
    return nil
}

func (strct *Pipeline) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Agent" field is required
    if strct.Agent == nil {
        return nil, errors.New("agent is a required field")
    }
    // Marshal the "agent" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"agent\": ")
	if tmp, err := json.Marshal(strct.Agent); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "auto_cancel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"auto_cancel\": ")
	if tmp, err := json.Marshal(strct.AutoCancel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Blocks" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "blocks" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"blocks\": ")
	if tmp, err := json.Marshal(strct.Blocks); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "execution_time_limit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"execution_time_limit\": ")
	if tmp, err := json.Marshal(strct.ExecutionTimeLimit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "fail_fast" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"fail_fast\": ")
	if tmp, err := json.Marshal(strct.FailFast); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "global_job_config" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"global_job_config\": ")
	if tmp, err := json.Marshal(strct.GlobalJobConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "promotions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"promotions\": ")
	if tmp, err := json.Marshal(strct.Promotions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "queue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"queue\": ")
	if tmp, err := json.Marshal(strct.Queue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Version" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "version" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Pipeline) UnmarshalJSON(b []byte) error {
    agentReceived := false
    blocksReceived := false
    versionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "agent":
            if err := json.Unmarshal([]byte(v), &strct.Agent); err != nil {
                return err
             }
            agentReceived = true
        case "auto_cancel":
            if err := json.Unmarshal([]byte(v), &strct.AutoCancel); err != nil {
                return err
             }
        case "blocks":
            if err := json.Unmarshal([]byte(v), &strct.Blocks); err != nil {
                return err
             }
            blocksReceived = true
        case "execution_time_limit":
            if err := json.Unmarshal([]byte(v), &strct.ExecutionTimeLimit); err != nil {
                return err
             }
        case "fail_fast":
            if err := json.Unmarshal([]byte(v), &strct.FailFast); err != nil {
                return err
             }
        case "global_job_config":
            if err := json.Unmarshal([]byte(v), &strct.GlobalJobConfig); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "promotions":
            if err := json.Unmarshal([]byte(v), &strct.Promotions); err != nil {
                return err
             }
        case "queue":
            if err := json.Unmarshal([]byte(v), &strct.Queue); err != nil {
                return err
             }
        case "version":
            if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
                return err
             }
            versionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if agent (a required property) was received
    if !agentReceived {
        return errors.New("\"agent\" is required but was not present")
    }
    // check if blocks (a required property) was received
    if !blocksReceived {
        return errors.New("\"blocks\" is required but was not present")
    }
    // check if version (a required property) was received
    if !versionReceived {
        return errors.New("\"version\" is required but was not present")
    }
    return nil
}

func (strct *PriorityItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "When" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "when" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"when\": ")
	if tmp, err := json.Marshal(strct.When); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PriorityItems) UnmarshalJSON(b []byte) error {
    valueReceived := false
    whenReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            valueReceived = true
        case "when":
            if err := json.Unmarshal([]byte(v), &strct.When); err != nil {
                return err
             }
            whenReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if value (a required property) was received
    if !valueReceived {
        return errors.New("\"value\" is required but was not present")
    }
    // check if when (a required property) was received
    if !whenReceived {
        return errors.New("\"when\" is required but was not present")
    }
    return nil
}

func (strct *PromotionsItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "auto_promote" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"auto_promote\": ")
	if tmp, err := json.Marshal(strct.AutoPromote); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "auto_promote_on" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"auto_promote_on\": ")
	if tmp, err := json.Marshal(strct.AutoPromoteOn); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "parameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"parameters\": ")
	if tmp, err := json.Marshal(strct.Parameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PipelineFile" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "pipeline_file" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"pipeline_file\": ")
	if tmp, err := json.Marshal(strct.PipelineFile); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PromotionsItems) UnmarshalJSON(b []byte) error {
    nameReceived := false
    pipeline_fileReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "auto_promote":
            if err := json.Unmarshal([]byte(v), &strct.AutoPromote); err != nil {
                return err
             }
        case "auto_promote_on":
            if err := json.Unmarshal([]byte(v), &strct.AutoPromoteOn); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        case "parameters":
            if err := json.Unmarshal([]byte(v), &strct.Parameters); err != nil {
                return err
             }
        case "pipeline_file":
            if err := json.Unmarshal([]byte(v), &strct.PipelineFile); err != nil {
                return err
             }
            pipeline_fileReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    // check if pipeline_file (a required property) was received
    if !pipeline_fileReceived {
        return errors.New("\"pipeline_file\" is required but was not present")
    }
    return nil
}

func (strct *QueueMap) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "processing" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"processing\": ")
	if tmp, err := json.Marshal(strct.Processing); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "scope" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"scope\": ")
	if tmp, err := json.Marshal(strct.Scope); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "when" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"when\": ")
	if tmp, err := json.Marshal(strct.When); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *QueueMap) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "processing":
            if err := json.Unmarshal([]byte(v), &strct.Processing); err != nil {
                return err
             }
        case "scope":
            if err := json.Unmarshal([]byte(v), &strct.Scope); err != nil {
                return err
             }
        case "when":
            if err := json.Unmarshal([]byte(v), &strct.When); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Secret) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "config_file_paths" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"config_file_paths\": ")
	if tmp, err := json.Marshal(strct.ConfigFilePaths); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "env_var_names" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"env_var_names\": ")
	if tmp, err := json.Marshal(strct.EnvVarNames); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Secret) UnmarshalJSON(b []byte) error {
    nameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "config_file_paths":
            if err := json.Unmarshal([]byte(v), &strct.ConfigFilePaths); err != nil {
                return err
             }
        case "env_var_names":
            if err := json.Unmarshal([]byte(v), &strct.EnvVarNames); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    return nil
}

func (strct *Task) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "agent" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"agent\": ")
	if tmp, err := json.Marshal(strct.Agent); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "boosters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"boosters\": ")
	if tmp, err := json.Marshal(strct.Boosters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "env_vars" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"env_vars\": ")
	if tmp, err := json.Marshal(strct.EnvVars); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "epilogue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"epilogue\": ")
	if tmp, err := json.Marshal(strct.Epilogue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "fail_fast" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"fail_fast\": ")
	if tmp, err := json.Marshal(strct.FailFast); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "jobs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"jobs\": ")
	if tmp, err := json.Marshal(strct.Jobs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "prologue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"prologue\": ")
	if tmp, err := json.Marshal(strct.Prologue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "secrets" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"secrets\": ")
	if tmp, err := json.Marshal(strct.Secrets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Task) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "agent":
            if err := json.Unmarshal([]byte(v), &strct.Agent); err != nil {
                return err
             }
        case "boosters":
            if err := json.Unmarshal([]byte(v), &strct.Boosters); err != nil {
                return err
             }
        case "env_vars":
            if err := json.Unmarshal([]byte(v), &strct.EnvVars); err != nil {
                return err
             }
        case "epilogue":
            if err := json.Unmarshal([]byte(v), &strct.Epilogue); err != nil {
                return err
             }
        case "fail_fast":
            if err := json.Unmarshal([]byte(v), &strct.FailFast); err != nil {
                return err
             }
        case "jobs":
            if err := json.Unmarshal([]byte(v), &strct.Jobs); err != nil {
                return err
             }
        case "prologue":
            if err := json.Unmarshal([]byte(v), &strct.Prologue); err != nil {
                return err
             }
        case "secrets":
            if err := json.Unmarshal([]byte(v), &strct.Secrets); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *WhenCondition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "When" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "when" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"when\": ")
	if tmp, err := json.Marshal(strct.When); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *WhenCondition) UnmarshalJSON(b []byte) error {
    whenReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "when":
            if err := json.Unmarshal([]byte(v), &strct.When); err != nil {
                return err
             }
            whenReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if when (a required property) was received
    if !whenReceived {
        return errors.New("\"when\" is required but was not present")
    }
    return nil
}
